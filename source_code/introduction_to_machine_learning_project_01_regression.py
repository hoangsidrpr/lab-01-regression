# -*- coding: utf-8 -*-
"""introduction_to_machine_learning_project_01_regression.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HqxL5ryBgznpgfXDxutYcsc_hSkAEqF5

# Lab 01 - HỒI QUY

Nhập môn Học Máy

Giảng viên lý thuyết: TS Bùi Tiến Lên

Hướng dẫn thực hành: Nguyễn Tiến Huy

Nhóm 13:

18120009 - Vương Gia Bảo

18120045 - Ngô Xuân Kiên

18120061 - Lê Nhựt Nam (Nhóm trưởng)

18120167 - Nguyễn Viết Dũng

[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/drive/1HqxL5ryBgznpgfXDxutYcsc_hSkAEqF5?usp=sharing) Click link này để mở Notebook trên môi trường Google Colab

# Chuẩn bị dữ liệu
Ở bước này, sử dụng wget để download hai tập tin ```train.csv``` và ```test.csv``` vào thư mục có tên là ```data```

Tập tin ```train.csv``` Là tập dữ liệu huấn luyện với các thông tin như:
- Age: Tuổi
- Sex: Giới tính
- BMI: Chỉ số khối cơ thể
- Children: Số lượng trẻ con/ người phụ thuộc
- Smoker: tình trạng hút thuốc
- Region: khu vực sinh sống
- Charges: Chi phí y tế cá nhân
"""

!mkdir data # Tạo thư mục có tên là data
!cd data # cdir vào data
# download dữ liệu vào thư mục data
!wget "https://drive.google.com/uc?export=download&id=19ig1GFDCioN_O2LjhF_JSzhwl_erengT" -O data/train.csv
!wget "https://drive.google.com/uc?export=download&id=1xvHczHpMFgPIQhyMKWT__fHimq0yVVK9" -O data/test.csv

"""# Import các thư viện cần thiết"""

from __future__ import division

# Thư viện hỗ trợ cho tính toán số học và xử lý dữ liệu dạng bảng
import numpy as np # import Numpy as alias np
import pandas as pd # Import Pandas as alias pd

# Thư viện hỗ trợ cho trực quan hóa dữ liệu
import matplotlib.pyplot as plt # From matplotlib import pyplot as alias plt
import seaborn as sns # Import Seaborn as alias sns

# Thư viện Sklearn
# Chọn và phân chia train, validation, test sets
from sklearn.model_selection import train_test_split as holdout

# Các mô hình hồi quy
from sklearn.linear_model import LinearRegression, Ridge, RidgeCV, Lasso, LassoCV

# Mô hình hồi quy đa thức
from sklearn.preprocessing import PolynomialFeatures

# Mô hình hồi quy rừng ngẫu nhiễn
from sklearn.ensemble import RandomForestRegressor

# Sklearn Metrics
from sklearn import metrics

# Hàm tính các đại lượng 
'''
- Mean Absolute Error - MAE: đo lường sự khác biệt giữa hai biến liên tục
- Mean squared error - MSE: trung bình của bình phương của sai số, thể hiện sự khác biệt giữa các giá trị được mô hình dự đoán và gía trị thực
- Explained Variance Score - EVS: 
- R2 Score: một con số thống kê tổng hợp khả năng giải thích của một phương trình. Nó biểu thị tỷ lệ biến thiên của biến phụ thuộc do tổng mức biến thiên của các biến giải thích gây ra 
'''
from sklearn.metrics import mean_absolute_error, mean_squared_error, explained_variance_score, r2_score, accuracy_score

# Kiểm định mô hình
from scipy.stats import pearsonr

# Chuẩn hóa dữ liệu
from sklearn.preprocessing import normalize, StandardScaler

from sklearn.model_selection import RepeatedKFold

"""# Đọc dữ liệu"""

# Đọc dữ liệu huấn luyện
# Do nhóm thực hiện đồ án trên môi trường Google Colab nên người dùng tự điều chỉnh đường dẫn cho phù hợp để đến vị trí tập tin train.csv, test.csv

# Đọc tập dữ liệu huấn luyện
train = pd.read_csv('/content/data/train.csv')

# Đọc tập dữ liệu test
test = pd.read_csv('/content/data/test.csv')

"""# Quan sát dữ liệu dựa trên các dự liệu trên tập huấn luyện và trực quan hóa

## Các Thông số của tập dữ liệu
"""

# Quan sát một số dữ liệu train đầu tiên
train.head()

# Quan sát một số dữ liệu test đầu tiên
test.head()

# Xem các đại lượng thống kê cơ bản của tập dữ liệu huấn luyện
"""
- count: Đếm số lượng phần tử của từng đặc trưng (cột trong tập dữ liệu)
- unique: 
- top:
- freq: Tần suất xuất hiện
- mean: Đại lượng trung bình
- std: độ lệch chuẩn
- min: giá trị nhỏ nhất của từng đặc trưng
- 25% Tứ phân vị một
- 50%: Tứ phân vị hai (Trung vị)
- 75%: Tứ phân vị ba
- max: giá trị lớn nhất của từng đặc trưng
"""
train.describe(include ='all')

# Xem các đại lượng thống kê cơ bản của tập dữ liệu huấn luyện
"""
- count: Đếm số lượng phần tử của từng đặc trưng (cột trong tập dữ liệu)
- unique: 
- top:
- freq: Tần suất xuất hiện
- mean: Đại lượng trung bình
- std: độ lệch chuẩn
- min: giá trị nhỏ nhất của từng đặc trưng
- 25% Tứ phân vị một
- 50%: Tứ phân vị hai (Trung vị)
- 75%: Tứ phân vị ba
- max: giá trị lớn nhất của từng đặc trưng
"""
test.describe(include ='all')

# Kiểm tra và tính tổng những giá trị null của tập train
# Như ở đây thì ta không có những giá trị null
train.isnull().sum()

# Kiểm tra và tính tổng những giá trị null của tập test
# Như ở đây thì ta không có những giá trị null
test.isnull().sum()

# Kiểm tra kiểu dữ liệu của các đặc trưng của tập train
# age: int64
# bmi, charges: float64
# sex, smoker, region: object
train.dtypes

# Kiểm tra kiểu dữ liệu của các đặc trưng của tập test
# age: int64
# bmi, charges: float64
# sex, smoker, region: object
test.dtypes

"""## Các thông số của đặc trưng chi phí y tế

Mục tiêu ở đây chi phí y tế cá nhân (charges), chúng ta cần những thông tin đến đặc trưng này như giá trị nhỏ nhất (min), giá trị lớn nhất (max), trung bình (mean), trung vị (median), trực quan hình dạng phân phối của nó
"""

# Giá trị nhỏ nhất của chi phí y tế
min_charges = train['charges'].min()
print('Min charges = {}'.format(min_charges))

# Giá trị lớn nhất của chi phí y tế
max_charges = train['charges'].max()
print('Max charges = {}'.format(max_charges))

# Giá trị trung bình của chi phí y tế
mean_charges = train['charges'].mean()
print('Mean charges = {}'.format(mean_charges))

# Giá trị trung vị của chi phí y tế
median_charges = train['charges'].min()
print('Median charges = {}'.format(median_charges))

# Độ lệch chuẩn của chi phí y tế
std_charges = train['charges'].std()
print('Standard deviation charges = {}'.format(std_charges))

# Trực quan hóa phân bố dữ liệu chi phí y tế
sns.set_style("dark")
ax = sns.displot(train, x='charges', kde = True, color='b', height=10, aspect=15/10)
plt.title('Phân phối của đặc trưng Charges')
plt.show()

"""**Nhận xét:** Chi phí trung bình của chi phí y tế lớn hơn rất nhiều so với Giá trị trung vị của chi phí y tế dẫn đến phân phối bị lệch sang một phía (sang trái), chứng tỏ dữ liệu tập trung không đều, do đó cần phải điều chỉnh bằng cách dùng **logarithm**"""

# Trực quan hóa phân bố dữ liệu chi phí y tế nhưng dùng dữ liệu đã chuẩn hóa bằng log
sns.set_style("dark")
ax = sns.displot(np.log(train['charges']), kde = True, color='b', height=10, aspect=15/10)
plt.title('Phân phối của đặc trưng Charges')
plt.show()

"""**Nhận xét:** Hình dạng biểu đồ sau khi dùng Numpy logarithm có dạng xấp xỉ phân phối chuẩn

## Tương quan giữa các đặc trưng trong dữ liệu
"""

fig, ax = plt.subplots(1, 1, figsize=(15, 15))
ax = sns.heatmap(train.corr(), annot=True, cmap='viridis')
plt.title('Ma trận tương quan các đặc trưng tập huấn luyện')
plt.show()

plt.figure(figsize=(15,10))
heatmap_df = pd.DataFrame({'Correalaton Rate':train.corr()['charges'].values}, index = train.corr()['charges'].index)
sns.heatmap(heatmap_df, annot = True)
plt.show()

"""**Nhận xét:** Giữa các cặp đặc trưng dữ liệu có mối quan hệ tương đối thấp, hệ số tương quan giữa chúng bé hơn 0.5. Điều này chúng ta cần suy đoán, cần phải thêm một số điều kiện khác nữa để rút ra mối quan hệ giữa chúng với chi phí y tế: vùng (Region), tình trạng hút thuốc (Smoker) và số lượng trẻ con/ người phụ thuộc (children)

## Phân tích chi phí y tế dựa trên một số dữ kiện liên quan

### Theo Vùng (Region)
Biểu đồ Bar chart trực quan chi phí y tế theo từng vùng: Northwest, Southwest, Northeast, Southest
"""

charges = train['charges'].groupby(train.region).sum().sort_values(ascending = True)
fig, ax = plt.subplots(1, 1, figsize=(15, 10))
ax = sns.barplot(x=charges.head(), y=charges.head().index, palette='Paired')
plt.title('Bar chart chi phí y tế theo từng vùng')
plt.show()

"""**Nhận xét**: Biểu đồ thể hiện chi phí y tế theo từng vùng. Chúng ta có 4 vùng cần xem xét: Northwest (vùng Đông Bắc), Southwest (vùng Tây Bắc), Northeast (vùng Tây Nam) và Southeast (vùng Đông Nam). Trong đó, vùng Tây Nam là vùng có chi phí y tế cao nhất, hai vùng Đông Bắc và Tây Bắc có chi phí y tế thấp hơn các vùng còn lại

### Theo giới tính (Sex) và Vùng (Region)

Biểu đồ Bar Chart trực quan chi phí y tế theo từng vùng: Northwest, Southwest, Northeast, Southest và nhóm giới tính: Nam (Male), Nữ (Female)
"""

fig, ax = plt.subplots(1, 1, figsize=(15, 10))
ax = sns.barplot(x='region', y='charges', hue='sex', data=train, palette='Paired')
plt.title('Bar chart chi phí y tế của mỗi vùng theo giới tính')
plt.show()

"""**Nhận xét**:
- xét viện phí tương đương nhau. chi phí y tế của nam giới cao hơn hẳn so với nữ giới => lượng người khám và chữa bệnh là nam giới nhiều hơn nữ giới. điều này xảy ra ở mọi khu vực và nổi bật hơn ở đông nam và tây nam.

### Theo tình trạng hút thuốc (Smoker) và vùng (Region)
Biểu đồ Bar Chart trực quan chi phí y tế theo từng vùng: Northwest, Southwest, Northeast, Southest phân loại theo tình trạng hút thuốc: yes/no
"""

fig, ax = plt.subplots(1,1, figsize=(15,10))
ax = sns.barplot(x = 'region', y = 'charges', hue='smoker', data=train, palette='Paired')
plt.title('Bar chart chi phí y tế của mỗi vùng theo tình trạng hút thuốc')
plt.show()

"""**Nhận xét:**
- số lượng người có hút thuốc cao hơn khoảng 3 lần so với người không hút.
- ở khu vực miền Bắc lượng người hút thuốc thấp hơn so với miền Nam.
- đồng thời ở khu vực miền Bắc lượng người không hút thuốc lớn hơn so với miền Nam.
=> tỉ lệ người không hút thuốc so với hút thuốc ở miền Bắc vượt trội với Miền Nam.

### Theo số lượng trẻ con/ người phụ thuộc (Children) và Vùng (Region)
Biểu đồ Bar Chart trực quan chi phí y tế theo từng vùng: Northwest, Southwest, Northeast, Southest phân loại theo số lượng trẻ con/ người phụ thuộc

Theo quan sát thống kê mô tả ở trên: số lượng trẻ con/ người phụ thuộc nằm trong khoảng [0, 5]
"""

fig, ax = plt.subplots(1,1, figsize=(15,10))
ax = sns.barplot(x = 'region', y = 'charges', hue='children', data=train, palette='Paired')
plt.title('Bar chart chi phí y tế của mỗi vùng theo  số lượng trẻ con/ người phụ thuộc (Children)')
plt.show()

"""**Nhận xét:**

- đa phần viện phí ở người có 3 đứa trẻ đứng cao ngoại trừ tây nam.
- viện phí của người có 5 đứa trẻ ở mọi khu vực là thấp nhất.
- viện phí của người không nuôi trẻ tương đối cao ?

"""

print(train.groupby(train.children).mean())

print(train.groupby(train.children).max())

print(train.groupby(train.bmi).mean())

"""### Theo tuổi (Age) và tình trạng hút thuốc (Smoker)

Đồ thị tuyến tính mối quan hệ giữa tuổi (Age) với chi phí y tế (Charges) theo loại của tình trạng hút thuốc (Smoker) [có(yes)/ không(no)]
"""

grid = sns.lmplot(x = 'age', y = 'charges', hue='smoker',data=train, palette='Paired', height=10, aspect=15/10)
grid.set(yscale="log")
plt.title('Quan hệ giữa Age và Charges dựa trên Smoker')
plt.show()

"""**Nhận xét:**

- viện phí của người hút thuốc cao hơn so với người không hút thuốc khoảng 23000.
- viện phí sẽ tăng dần đều theo số tuổi của người bệnh dù có hút thuốc hay không.
=> số tiền viện phí tăng thêm cần bỏ ra khi khám phụ thuộc vào tuổi, hút thuốc sẽ tăng thêm số tiền cố định thay vì tỉ lệ tăng dần.
 
"""

sns.FacetGrid(train, hue="smoker", height=15).map(plt.scatter, "age", "charges").add_legend()
sns.regplot(x="age", y="charges", data=train, scatter=False,)
plt.title('Quan hệ giữa Age và Charges dựa trên Smoker')
plt.show()

"""### Theo chỉ số BMI (bmi) và tình trạng hút thuốc
Đồ thị tuyến tính mối quan hệ giữa chỉ số BMI (bmi) với chi phí y tế (Charges) theo loại của tình trạng hút thuốc (Smoker) [có(yes)/ không(no)]
"""

grid = sns.lmplot(x = 'bmi', y = 'charges', hue='smoker', data=train, palette='Paired', height=10, aspect=15/10)
#grid.set(yscale='log')
plt.title('Quan hệ bmi và charges theo smoker')
plt.show()

"""**Nhận xét:**

- biểu đồ cho ta thấy số tiền viện phí khi không hút thuốc sẽ ổn định bất kể số bmi. 
- viện phí của người không hút thuốc tăng với tỉ lệ cực thấp nếu không hút thuốc.
- viện phí của người hút thuốc sẽ tăng cao tỉ lệ thuận với bmi. 
- ở người hút thuốc tỉ lệ người có bmi thấp cao hơn so với ở người không hút. 

"""

sns.lmplot(x = 'age', y = 'charges', data=train, palette='Paired', height=10, aspect=15/10)
plt.title('Quan hệ bmi và charges theo smoker')
plt.show()

sns.FacetGrid(train, hue="smoker", height=15).map(plt.scatter, "bmi", "charges").add_legend()
sns.regplot(x="bmi", y="charges", data=train, scatter=False,)
plt.title('Quan hệ giữa Bmi và Charges dựa trên Smoker')
plt.show()

"""**Nhận xét:**


- người có bmi cao sẽ phải trả nhiều tiền viện phí hơn so với bmi thấp.
- người hút thuốc thường có bmi thấp và viện phí cao hơn người không hút.

### Theo số lượng trẻ con/ người phụ thuộc (Children) và tình trạng hút thuốc

Đồ thị tuyến tính mối quan hệ giữa số lượng trẻ con/ người phụ thuộc (Children) với chi phí y tế (Charges) theo loại của tình trạng hút thuốc (Smoker) [có(yes)/ không(no)]
"""

grid = sns.lmplot(x = 'children', y = 'charges', hue='smoker', data=train, palette='Paired', height=10, aspect=15/10)
#grid.set(yscale='log')
plt.title('Quan hệ children và charges dựa trên smoker')
plt.show()

sns.FacetGrid(train, hue="smoker", height=15).map(plt.scatter, "children", "charges").add_legend()
sns.regplot(x="children", y="charges", data=train, scatter=False,)
plt.title('Quan hệ giữa children và Charges dựa trên Smoker')
plt.show()

"""**nhận xét:**

- người có càng nhiều đứa trẻ lại tỉ lệ hút thuốc càng thấp.
- viện phí ở người có 2-3 đứa trẻ là cao nhất.

## Xử lý dữ liệu
"""

# Xem kiểu dữ liệu tập huấn luyện
train.dtypes

train.sex.value_counts()

train.smoker.value_counts()

train.region.value_counts()

# Thay thế [female, male] trong cột sex thành dạng nhị phân [0, 1]
train['sex'] = train['sex'].astype('category').cat.codes

# Thay thế [yes, no] trong cột smoker thành dạng nhị phân [1, 0]
train['smoker'] = train['smoker'].astype('category').cat.codes

# Thay thế [southeast, northeast, southwest, northwest] -> [0, 1, 2, 3]
train['region'] = train['region'].astype('category').cat.codes

# Thay thế [female, male] trong cột sex thành dạng nhị phân [0, 1]
test['sex'] = test['sex'].astype('category').cat.codes

# Thay thế [yes, no] trong cột smoker thành dạng nhị phân [1, 0]
test['smoker'] = test['smoker'].astype('category').cat.codes

# Thay thế [southeast, northeast, southwest, northwest] -> [0, 1, 2, 3]
test['region'] = test['region'].astype('category').cat.codes

# Xem kiểu dữ liệu tập huấn luyện
train.dtypes

# Xem kiểu dữ liệu tập huấn luyện
train.head()

test.head()

"""# Lựa chọn mô hình Máy học cho bài toán

Vấn đề đặt ra, dựa trên những dự kiện (các biến, giả định rằng các biến này độc lập với nhau) về tuổi (age), giới tính (sex), bmi, số lượng trẻ em (children), vùng dân cư (region), ta có thể đưa ra dự đoán về giá trị của chi phí y tế cá nhân (biến phụ thuộc) một cách chính xác nhất có thể
	
Đây là một bài toán có thể áp dụng Mô hình Tuyến tính và Phân tích Hồi quy

# Cài đặt mô hình Máy học

## Cài đặt thuật toán Linear Regression
"""

# Chuẩn bị dữ liệu
x_train = train.drop(['charges'], axis=1)
x_test = test.drop(['charges'], axis = 1)
y_train = train['charges']
y_test = test['charges']
print("Train features shape : ", x_train.shape)
print("Train target shape   : ", y_train.shape)
print("Test features shape  : ", x_test.shape)
print("Test target shape    : ", y_test.shape)

# Mô hình hồi quy tuyến tính
Lin_reg = LinearRegression(fit_intercept=True)
Lin_reg.fit(x_train, y_train)

# Hệ số của các đặc trưng, hệ số chặn trong mô hình regression của dữ liệu, điểm số trên tập test
print('Linear regression intercept = ', Lin_reg.intercept_) # hệ số bậc 0
print('Linear regression coefficient = ', Lin_reg.coef_) # hệ số bậc 1
print('Linear regression score on test data = ', Lin_reg.score(x_test, y_test)) #: phương sai

# Hệ số của các đặc trưng
for i in range(len(x_train.columns)):
    print(train.columns[i], ": ", Lin_reg.coef_[i])

# Test trên tập huấn luyện
y_train_pred = Lin_reg.predict(x_train)

rmse = np.sqrt(mean_squared_error(y_train,y_train_pred))
r2 = r2_score(y_train,y_train_pred)

print('RMSE: ', rmse)
print('R2: ', r2)

# Predict
X_test = test.drop(['charges'], axis = 1)
y_test = test['charges']
y_pred = Lin_reg.predict(X_test)
mae = mean_absolute_error(y_test, y_pred)
mse = mean_squared_error(y_test, y_pred)
rmse = (np.sqrt(mse))
mv = explained_variance_score(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

output = pd.DataFrame(y_test[0:10])
output['Predicted'] = y_pred[0:10]
output['Difference'] = output['Predicted'] - output['charges']
print(output, "\n")

print("Model testing performance:")
print("--------------------------")
print("Mean Absolute Error is", round(mae,1))
print('RMSE is {}'.format(rmse))
print('R2 score is {}'.format(r2))
print("Variance explained by model", round(mv*100,5), "%")

# plotting
plt.figure(figsize=(12,8))

plt.scatter(y_train_pred, y_train_pred - y_train,
          c = 'gray', marker = 'o', s = 35, alpha = 0.5,
          label = 'Train data')
plt.scatter(y_pred, y_pred - y_test,
          c = 'blue', marker = 'o', s = 35, alpha = 0.7,
          label = 'Test data')
plt.title('Scatter plot prediction on train and test data')
plt.xlabel('Predicted values')
plt.ylabel('Actual values')
plt.legend(loc = 'upper right')
plt.hlines(y = 0, xmin = 0, xmax = 60000, lw = 2, color = 'red')
plt.grid()
plt.show()

"""## Nhận xét về Linear Regression

1.   dựa vào bộ train data, Linear Regression tính toán với bình phương phương sai thấp nhất của dữ liệu so với dữ liệu cần dự đoán, từ đó tìm hệ số slope của mỗi dữ liệu đối với kết quả cần được dự đoán (coefficient). từ đó tìm ra được chi phí phù hợp khi từng loại dữ liệu được đặt ra.
2.   công thức Linear Regression:
 predict = intercept + slopeAge * dataAge + slopeSex * dataSex + slopeBMI * dataBMI + ...

## Cài đặt thuật toán Ridge Regression
"""

# Chuẩn hóa dữ liệu
# Chia tập huấn luyện, tập test
x_train = train.drop(['charges'], axis = 1)
x_test = test.drop(['charges'], axis = 1)
y_train = train['charges']
y_test = test['charges']
print("Train features shape : ", x_train.shape)
print("Train target shape   : ", y_train.shape)
print("Test features shape  : ", x_test.shape)
print("Test target shape    : ", y_test.shape)

# Khởi tạo dãy alphas
alphas = np.logspace(-10, 10, 30)

# Khởi tạo mô hình RidgeCV lựa chọn alpha tối ưu
scores = np.empty_like(alphas)

for i,a in enumerate(alphas):
    ridge = Ridge()
    ridge.set_params(alpha=a)
    ridge.fit(x_train, y_train)
    scores[i] = ridge.score(x_test, y_test) 

model = RidgeCV(alphas=alphas)
model.fit(x_train, y_train)
model_score = model.score(x_test, y_test)
alpha = model.alpha_
print(alpha)

plt.figure(figsize=(15,10))
fig = plt.plot(alphas, scores, '-ko')

ax = plt.axhline(model_score , color='b', ls='--')
ax = plt.axvline(alpha , color='r', ls='--')
plt.xlabel(r'$\alpha$')
plt.ylabel('Score')
plt.xscale('log')
plt.grid()
plt.show()

# Khởi tạo mô hình hồi quy Ridge
ridge_reg = Ridge(alpha=alpha)
ridge_reg.fit(x_train, y_train)

# Hệ số của các đặc trưng, hệ số chặn trong mô hình Ridge Regression của dữ liệu, điểm số trên tập test
print('Ridge regression intercept = ', ridge_reg.intercept_)
print('Ridge regression coefficient = ', ridge_reg.coef_)
print('Ridge regression score on test data = ', ridge_reg.score(x_test, y_test))

for i in range(len(x_train.columns)):
    print(train.columns[i], ": ", ridge_reg.coef_[i])

# Dự đoán trên tập huấn luyện
y_train_pred = ridge_reg.predict(x_train)

rmse = np.sqrt(mean_squared_error(y_train,y_train_pred))
r2 = r2_score(y_train,y_train_pred)

print('RMSE: ', rmse)
print('R2: ', r2)

# Thay thế [female, male] trong cột sex thành dạng nhị phân [0, 1]
test['sex'] = test['sex'].astype('category').cat.codes

# Thay thế [yes, no] trong cột smoker thành dạng nhị phân [1, 0]
test['smoker'] = test['smoker'].astype('category').cat.codes

# Thay thế [southeast, northeast, southwest, northwest] -> [0, 1, 2, 3]
test['region'] = test['region'].astype('category').cat.codes

X_actual = test.drop(['charges'], axis = 1)
y_actual = test['charges']
y_pred = ridge_reg.predict(X_actual)
mae = mean_absolute_error(y_actual, y_pred)
mse = mean_squared_error(y_actual, y_pred)
rmse = (np.sqrt(mse))
mv = explained_variance_score(y_actual, y_pred)
r2 = r2_score(y_actual, y_pred)

output = pd.DataFrame(y_actual[0:10])
output['Predicted'] = y_pred[0:10]
output['Difference'] = output['Predicted'] - output['charges']
print(output, "\n")

print("Model testing performance:")
print("--------------------------")
print("Mean Absolute Error is", round(mae,1))
print('RMSE is {}'.format(rmse))
print('R2 score is {}'.format(r2))
print("Variance explained by model", round(mv*100,5), "%")

x_train_pred = ridge_reg.predict(x_train)
x_test_pred = ridge_reg.predict(x_test)

plt.figure(figsize=(15,10))

plt.scatter(x_train_pred, x_train_pred - y_train,
          c = 'gray', marker = 'o', s = 35, alpha = 0.5,
          label = 'Train data')
plt.scatter(x_test_pred, x_test_pred - y_test,
          c = 'blue', marker = 'o', s = 35, alpha = 0.7,
          label = 'Test data')
plt.xlabel('Predicted values')
plt.ylabel('Actual values')
plt.legend(loc = 'upper right')
plt.hlines(y = 0, xmin = 0, xmax = 60000, lw = 2, color = 'red')
plt.show()

"""## Nhận xét về  Ridge Regression

1.   tương tự với Linear Regression, Ridge cũng tìm hệ dữ liệu với phương sai thấp nhất.
2. Ridge tìm ra hệ số bias lớn hơn so với Linear để giảm hoặc tăng tính ảnh hưởng của từng loại dữ liệu lên kết quả được predict.
3. Linear tính toán predict = tổng bình phương phương sai thấp nhất với slope * data.
    
   * Ridge tính toán predict = tổng bình phương phương sai thấp nhất + lambda * slope ^ 2.

## Cài đặt thuật toán Lasso Regression
"""

# Chuẩn bị dữ liệu
x_train = train.drop(['charges'], axis = 1)
x_test = test.drop(['charges'], axis = 1)
y_train = train['charges']
y_test = test['charges']
print("Train features shape : ", x_train.shape)
print("Train target shape   : ", y_train.shape)
print("Test features shape  : ", x_test.shape)
print("Test target shape    : ", y_test.shape)

# Chọn alpha
alphas = np.logspace(-10, 10, 20)
scores = np.empty_like(alphas)

for i,a in enumerate(alphas):
    lasso = Lasso()
    lasso.set_params(alpha=a)
    lasso.fit(x_train, y_train)
    scores[i] = lasso.score(x_test, y_test) 

lassocv = LassoCV()
lassocv.fit(x_train, y_train)
lassocv_score = lassocv.score(x_train, y_train)
lassocv_alpha = lassocv.alpha_

plt.figure(figsize=(15,10))
fig = plt.plot(alphas, scores, '-ko')

ax = plt.axhline(lassocv_score, color='b', ls='--')
ax = plt.axvline(lassocv_alpha, color='r', ls='--')
plt.xlabel(r'$\alpha$')
plt.ylabel('Score')
plt.xscale('log')
plt.grid()
plt.show()

lassocv_alpha

# Khởi tạo mô hình
lasso = Lasso(alpha=np.log(lassocv_alpha), fit_intercept=True, normalize=True)

# Khớp dữ liệu tập huấn luyện
lasso.fit(x_train, y_train)

# Hệ số của các đặc trưng, hệ số chặn trong mô hình regression của dữ liệu, điểm số trên tập test
print(lasso.intercept_)
print(lasso.coef_)
print(lasso.score(x_test, y_test))

# Hệ số của các đặc trưng
for i in range(len(x_train.columns)):
    print(train.columns[i], ": ", lasso.coef_[i])

# Dự đoán trên tập huấn luyện
y_train_pred = lasso.predict(x_train)

rmse = np.sqrt(mean_squared_error(y_train,y_train_pred))
r2 = r2_score(y_train,y_train_pred)

print('RMSE: ', rmse)
print('R2: ', r2)

# Dự đoán
X_actual = test.drop(['charges'], axis = 1)
y_actual = test['charges']
y_pred = lasso.predict(X_actual)
mae = mean_absolute_error(y_actual, y_pred)
mse = mean_squared_error(y_actual, y_pred)
rmse = (np.sqrt(mse))
mv = explained_variance_score(y_actual, y_pred)
r2 = r2_score(y_actual, y_pred)

output = pd.DataFrame(y_actual[0:10])
output['Predicted'] = y_pred[0:10]
output['Difference'] = output['Predicted'] - output['charges']
print(output, "\n")

print("Model testing performance:")
print("--------------------------")
print("Mean Absolute Error is", round(mae,1))
print('RMSE is {}'.format(rmse))
print('R2 score is {}'.format(r2))
print("Variance explained by model", round(mv*100,5), "%")

# Trực quan train data, test data giữa giá tri dự đoán và giá trị thực sự
x_train_pred = lasso.predict(x_train)
x_test_pred = lasso.predict(x_test)

plt.figure(figsize=(15,10))

plt.scatter(x_train_pred, x_train_pred - y_train,
          c = 'gray', marker = 'o', s = 35, alpha = 0.5,
          label = 'Train data')
plt.scatter(x_test_pred, x_test_pred - y_test,
          c = 'blue', marker = 'o', s = 35, alpha = 0.7,
          label = 'Test data')
plt.xlabel('Predicted values')
plt.ylabel('Actual values')
plt.legend(loc = 'upper right')
plt.hlines(y = 0, xmin = 0, xmax = 60000, lw = 2, color = 'red')
plt.grid()
plt.show()

"""## Nhận xét về Lasso Regression

1.   tương tự với Ridge Regression, Lasso cũng tìm hệ dữ liệu với phương sai thấp nhất.
3. Ridge tính toán predict = tổng bình phương phương sai thấp nhất với sai số là lambda * slope^2 .
    
   * Ridge tính toán predict = tổng bình phương phương sai thấp nhất + lambda * |slope|.

## Cài đặt thuật toán Random Forest Regressor
"""

# Chuẩn bị dữ liệu
X_train = train.drop(['charges'], axis=1)
y_train = train.charges
X_test = test.drop(['charges'], axis = 1)
y_test = test['charges']

# Khởi tạo mô hình và khớp dữ liệu trên tập huấn luyện
rf_regressor = RandomForestRegressor(n_estimators = 100, random_state = 0)
rf_regressor.fit(X_train, y_train)

# Dự đoán trên tập huấn luyện
y_train_pred = rf_regressor.predict(X_train)

rmse = np.sqrt(mean_squared_error(y_train,y_train_pred))
r2 = r2_score(y_train,y_train_pred)

print('RMSE: ', rmse)
print('R2: ', r2)

# Điểm số của các đặc trưng: con số này đại diện cho mức độ quan trọng của đặc trưng, càng gần 1 thì đóng góp của nó càng lớn
rf_regressor.feature_importances_

# Trực quan hóa điểm số của các đặc trưng thông quan biểu đồ cột
feat_importances = pd.Series(rf_regressor.feature_importances_, index=X_train.columns)
feat_importances.nlargest(6).plot(kind='barh', figsize=(15, 10))
plt.show()

# Dự đoán và đánh giá mô hình
y_pred_test = rf_regressor.predict(X_test)
mae = mean_absolute_error(y_test, y_pred_test)
mse = mean_squared_error(y_test, y_pred_test)
rmse = (np.sqrt(mse))
mv = explained_variance_score(y_test, y_pred_test)
r2 = r2_score(y_test, y_pred_test)

output = pd.DataFrame(y_test[0:10])
output['Predicted'] = y_pred_test[0:10]
output['Difference'] = output['Predicted'] - output['charges']
print(output, "\n")

print("Model testing performance:")
print("--------------------------")
print("Mean Absolute Error is", round(mae,1))
print('RMSE is {}'.format(rmse))
print('R2 score is {}'.format(r2))
print("Variance explained by model", round(mv*100,5), "%")

# Trực quan train data, test data giữa giá tri dự đoán và giá trị thực sự
fig = plt.figure(figsize=(15,10))
ax = plt.gca()
ax = plt.scatter(y_train_pred, y_train_pred - y_train,
          c = 'gray', marker = 'o', s = 35, alpha = 0.5,
          label = 'Train data')
ax = plt.scatter(y_pred_test, y_pred_test - y_actual,
          c = 'blue', marker = 'o', s = 35, alpha = 0.7,
          label = 'Test data')
plt.xlabel('Predicted values')
plt.ylabel('Actual values')
plt.legend(loc = 'upper right')
plt.hlines(y = 0, xmin = 0, xmax = 60000, lw = 2, color = 'red')
plt.grid()
plt.show()

"""## Nhận xét về Random Forest Regressor

các bước thực hiện RFR
1.   tạo ra bộ dữ liệu bootstrapped để 1 phần dữ liệu train.


*   Tạo bộ cây quyết định bằng bộ dữ liệu bootstrapped tỉ lệ 1-1.
2. bộ dữ liệu trên được xem là random forest.
3. phần dữ liệu còn lại của bộ train được sử dụng để tính độ chính xác của rừng cây.


*   bằng cách cho những bộ dữ liệu đi qua từng bootstrap ( rừng bootstrap) ta có thể tính được tỉ lệ đúng sai của rừng cây đó.

4. sau khi tính được độ đúng sai của rừng. chúng ta quay lại bước 1 và tạo ra những rừng cây mới với cấu trúc khác.

5. so sánh độ đúng sai của những rừng cây được tạo ra và chọn rừng cây phù hợp nhất.

## Cài đặt thuật toán Polynomial Regression
"""

# Training data
X_train = train.drop(['charges'], axis=1)
y_train = train.charges

# Test data
X_test = test.drop(['charges'], axis=1)
y_test = test.charges

# Shape X training data
X_train.shape

# Shape y training data
y_train.shape

# Chọn bậc tối ưu
rmses = []
degrees = np.arange(1, 10)
min_rmse, min_deg = 1e10, 0

for deg in degrees:

    # Train features
    poly_features = PolynomialFeatures(degree=deg)
    x_poly_train = poly_features.fit_transform(X_train)

    # Linear regression
    poly_reg = LinearRegression()
    poly_reg.fit(x_poly_train, y_train)

    # Compare with test data
    x_poly_test = poly_features.fit_transform(X_test)
    poly_predict = poly_reg.predict(x_poly_test)
    poly_mse = mean_squared_error(y_test, poly_predict)
    poly_rmse = np.sqrt(poly_mse)
    rmses.append(poly_rmse)
    
    # Cross-validation of degree
    if min_rmse > poly_rmse:
        min_rmse = poly_rmse
        min_deg = deg

print('Best degree {} with RMSE {}'.format(min_deg, min_rmse))

# Plotting choose degree
fig = plt.figure(figsize=(15,10))
ax = fig.add_subplot(111)
ax.plot(degrees, rmses, '-ko')
ax.set_yscale('log')
ax.set_xlabel('Degree')
ax.set_ylabel('RMSE')
plt.grid()
plt.show()

# Assigment best degree that calculated
nb_degree = min_deg
poly_features = PolynomialFeatures(degree=nb_degree)
x_poly_train = poly_features.fit_transform(X_train)

# Train features
poly_reg = LinearRegression()
poly_reg.fit(x_poly_train, y_train)

# define and train a model
print('Polynomial intercept = ', poly_reg.intercept_)
print('Polynomial coefficient = ', poly_reg.coef_)
print('Polynomial score on test data = ', poly_reg.score(poly_features.fit_transform(X_test), y_test))

# calculate bias and variance
y_train_pred = poly_reg.predict(poly_features.fit_transform(X_train))

rmse = np.sqrt(mean_squared_error(y_train,y_train_pred))
r2 = r2_score(y_train,y_train_pred)

print('RMSE: ', rmse)
print('R2: ', r2)

# Predict
X_actual = test.drop(['charges'], axis = 1)
y_actual = test['charges']
y_pred_test = poly_reg.predict(poly_features.fit_transform(X_actual))
mae = mean_absolute_error(y_actual, y_pred_test)
mse = mean_squared_error(y_actual, y_pred_test)
rmse = (np.sqrt(mse))
mv = explained_variance_score(y_actual, y_pred_test)
r2 = r2_score(y_actual, y_pred_test)

output = pd.DataFrame(y_actual[0:10])
output['Predicted'] = y_pred_test[0:10]
output['Difference'] = output['Predicted'] - output['charges']
print(output, "\n")

print('Model testing performance:')
print('--------------------------')
print('Mean Absolute Error is ', (round(mae,1)))
print('RMSE is {}'.format(rmse))
print('R2 score is {}'.format(r2))
print('Variance explained by model is ', round(mv*100,5), '%')

fig = plt.figure(figsize=(15,10))
ax = plt.gca()
ax = plt.scatter(y_train_pred, y_train_pred - y_train,
          c = 'gray', marker = 'o', s = 35, alpha = 0.5,
          label = 'Train data')
ax = plt.scatter(y_pred_test, y_pred_test - y_actual,
          c = 'blue', marker = 'o', s = 35, alpha = 0.7,
          label = 'Test data')
plt.xlabel('Predicted values')
plt.ylabel('Actual values')
plt.legend(loc = 'upper right')
plt.hlines(y = 0, xmin = 0, xmax = 60000, lw = 2, color = 'red')
plt.grid()
plt.show()

"""## Nhận xét về  Polynomial Regression


1.   Polynomial Regression tiến bộ hơn so với Linear regression.
2.   Polynomial Regression thay đổi giá trị phụ thuộc theo từng data được train và tiến bộ dần với bộ dữ liệu lớn.
3.   Polynomial nhạy cảm với các outlier, tuy nhiên với bộ dữ liệu y tế trên, Polynomial không bị ảnh hưởng nhiều do được phát triển đủ tốt để thực hiện dự đoán với sai số thấp.
4.   công thức chung Polynomial
 Predict = intercept + theta1 * (slopeSex * dataSex + slopeBMI * dataBMI + ... ) + theta2 * ( slopeSex * dataSex + slopeBMI * dataBMI + ... ) + theta3 * ( slopeSex * dataSex + slopeBMI * dataBMI + ... )

# Nhận xét về kết quả dự đoán
 
- thuật toán sẽ dự đoán tốt hơn ở những bộ dữ liệu có chi phí y tế thấp và sai lệch ở những chi phí cao.
- test data được dự đoán với kết quả tốt hơn so với train data.
- những kết quả dự đoán cao sẽ sai lệch khoảng 10000, không dự đoán đúng tuy nhiên độ sai lệch cũng không lớn.
"""